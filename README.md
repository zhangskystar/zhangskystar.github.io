### 软件的定义及特点
* 软件的定义
    * 计算机系统中的程序及文档
    * 程序是计算任务的处理对象和处理规则的描述
    * 文档是为了便于了解程序所需的阐明性资料
* 软件的特点
    * 软件是无形的、不可见的逻辑实体
    * 软件是设计开发的、不是生产制造的
    * 软件在使用的过程中有磨损、老化的问题
    * 软件是定制开发的
    * 软件是复杂的
    * 软件的开发成本高
    * 软件易于复制
    * 软件的质量要求较高
    * 软件的开发和运行都离不开相关的计算机系统环境
    * 软件的开发工作牵涉到很多社会因素
*  软件的功能划分分类
    * **系统软件**
    * **支撑软件**
    * **应用软件**

### 软件工程的起源和概念
*在信息产业中，微电子是基础，计算机和网络是载体，软件是核心*

* 软件开发的三个阶段
    *  个人程序时期（1947年—1950年代末）
       > 这个时期，程序员使用的语言主要是**机器语言**和**汇编语言**，负责程序的开发运行和维护，这是一种私人化的软件环境

    *  软件作坊时期（1960年代初—1960年代末）
      > 多人分工合作，共同完成一个程序的编制，对项目开发进行管理

    *  软件工程时期（1970年代初至今）

### 软件工程的定义
* 《计算机科学技术百科全书》的定义
> 软件工程是应用计算机科学、数学、逻辑学及管理科学等原理，开发软件的工程。软件工程借鉴传统工程的原则、方法，以提高质量、降低成本和改进算法。其中，计算机科学、数学用于构建模型与算法，工程科学用于制定规范、设计范型(paradigm)、评估成本及确定权衡，管理科学用于计划、资源、质量、成本等管理。

*软件工程是一门指导软件开发和维护的工程学科，是一门交叉性学科*

* IEEE：在软件工程术语汇编中的定义
    * 软件工程是：
        * 1.将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件
        * 2.在1中所述方法的研究

* FritzBauer：在NATO会议上给出的定义
 > 建立并使用完善的工程化原则，以较经济的手段获得能在实际机器上有效运行的可靠软件的一系列方法。

* 软件工程概念提出的目的
    * 倡导以工程的原理、原则和方法进行软件开发，以解决软件危机

### 软件开发的本质和基本手段
* 软件开发的含义
> 实现问题域中的概念和处理逻辑到运行平台的概念和处理逻辑的映射

*  软件开发的本质
> 不同抽象层术语之间的映射，不同抽象层处理逻辑的映射

* 实现映射的基本手段：建模
    * 运用所掌握的知识，通过抽象，给出该问题的一个结构

### 软件工程框架
*软件工程可定义为三元组<目标，原则，活动>*

* 作用
    * （1）给出了软件所涉及软件工程的**工程要素**

    * （2）给出了**各要素之间的关系**

    * （3）给出了软件工程学科所**研究的主要内容**

* 软件工程的目标
>生产具有正确性、可用性以及开销适宜的产品

* 软件工程的活动
	* 生产一个最终满足需求且达成软件目标的软件产品所需的步骤，主要包括需求、设计、实现、确认和支持等活动
    	* 需求：定义问题，即建立系统模型（需求获取、需求定义、需求规约）
    	* 设计：**总体设计**和**详细设计**
    	* 实现：把设计结果转换成可执行的程序代码
    	* 确认：需求复审、设计复审以及程序测试，主要任务是软件测试
    支持活动：修改和完善
* 软件工程的原则
    * 选取适宜的开发模型
    * 提供高质量的工程支持
    * 重视开发过程的管理
  
### 软件生存周期过程的概念
* 软件生存周期在软件工程知识框架的位置

* 软件生存周期的概念
> 软件产品或系统的一系列活动的全周期。从行成概念开始，历经开发、交付使用、在使用中不断修订和演化，直到最后被淘汰

* 软件生存周期过程的概念
	* 开发逻辑是获取正确软件的关键
    	* 软件过程（process）：活动的一个集合
    	* 活动(activity)：任务的一个集合，“软件过程”和“活动”相当于复合映射
    	* 任务(task)：将输入转换为输出的操作，“任务”相当于原子映射

### 软件生存周期过程的分类
> 按承担软件开发工作的主体，将软件生存周期过程分为三类：

* 基本过程，是指那些与软件生产直接相关的活动集
	* 按过程中活动的不同主体，将基本过程分为5个过程：获取过程、供应过程、开发过程、运行过程、维护过程

* 支持过程，是有关各方按其目标从事的一系列支持活动集
	* 按过程中活动的不同主体，将支持过程分为8个过程：文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合过程、审计过程、问题解决过程等

* 组织过程，是指那些与软件生产组织有关的活动集
	* 分为7个过程：管理过程、基础设施过程、改进过程、人力资源过程、资产管理过程、复用程序过程、领域软件工程过程
* 各类过程之间的关系

### 软件生存周期模型的概念
* 模型与过程之间的关系
* 软件生存周期模型的概念
> IEEE描述：一个包括软件产品开发、运行和维护中有关过程、活动和任务的框架，覆盖了从该系统的需求定义到系统的使用终止

> 《计算机科学技术百科全书》描述：“软件开发模型”，并把它定义为软件过程、活动、任务的结构框架

### 常见的软件生存周期模型
* 瀑布模型
* 增量模型
* 演化模型
* 喷泉模型

### 需求的作用
* 现代系统中软件的作用
    * 软件通常是任何系统中最为复杂的部分，在系统创建时，软件的开发经常成为最大的技术挑战

* 软件在系统工作中的作用
* 自顶向下和自底向上的开发
    * 不论是采用自顶向下的软件开发，还是采用自底向上的软件开发，软件需求是软件开发的工作基础

### 需求的定义
* 定义
> 一个需求是一个有关“要予构造”的陈述，描述了待开产品/系统（或顶）功能上的能力、性能参数或者其它性质

* 需求的基本性质
    * IEEE标准：必要的，无歧义的，可测的，可跟踪的，可测量的
    > 注：确定一个需求是否满足以上5个性质是复杂耗时的过程

### 需求的分类
* 功能
	* 功能需求规约了系统或系统构件必须执行的功能

* 性能
    * 性能需求规约了一个系统或系统构件必须具有的性能特性
	* 注意：性能需求隐含了一些满足功能需求的设计方案，经常对设计产生一些关键的影响。
	> 例如，排序，关于花费时间的规约将确定哪种算法是可行的

* 外部接口
    * 外部接口规约了系统或系统结构必须与之交互的硬件，软件或数据库元素。它们可能规约了其格式、时间或其他因素
		* 系统接口
		* 用户接口
		* 硬件接口
		* 软件接口
		* 通讯接口
		* 内存约束
		* 操作
		* 地点需求
* 设计约束
	* 设计约束限制了系统或系统构件的设计方案。就约束的本身而言，对其进行权衡或调整是相当困难的，甚至是不可能的。它们必须予以满足。这一性质，是与其它需求的最主要差别。为了满足功能、性能和其它需求，许多设计约束将对软件项目规划、所需要的附加成本和工作产生直接影响
	
* 质量属性
	* 质量属性规约了软件产品必须具有的一个性质是否达到质量方面一个所期望的水平
    	* 可靠性，软件系统在指定环境中没有失败而正常运行的概率
    	* 存活性，当系统的某一部分系统不能运行时，该软件继续运行或支持关键功能的可能性
    	* 可维护性，发现和改正一个软件故障或对特定的范围进行修改所要求的平均工作
    	* 用户友好性，学习和使用一个软件系统的容易程度
    	* 安全性，在一个预订的时间内，使软件系统安全的可能性
    	* 可移植性，软件系统运行的平台类型

### 需求发现
* 自悟（Introspection)
    * 需求人员把自己作为系统的最终用户，审视该系统并提出问题：“如果是我使用这一系统，则我需要…”
        * 适用条件：需求工程师不能直接与用户进行交流，自悟是一种比较有吸引力的方法，可能确实是必须的
        * 成功条件：若使自悟是成功的，需求人员必须具有比最终用户还要多的应用领域和过程方面的知识，并具有良好的想象能力

* 交谈（Individual interviews)
    * 为了确定系统应该提供的功能，需求人员通过提出问题，用户回答，直接询问用户想要的是一种比自悟更好的技术
        * 成功条件：交谈通常是一种比自悟更好的技术。这种途径成功与否依赖于：需求人员是否具有“正确提出问题”的能力；回答人员是否具有“揭示需求本意”的能力
        * 存在的风险：在交谈期间需求可能不断增长，或是以前没有认识到的合理需求的一种表现，说是“完美蠕行”病症的一种提现，以至于很难予以控制，可能导致超出项目成本的限制
        * 应对措施：项目管理人员和客户管理应该定期地对交谈过程的结果进行复审。其中具有挑战的问题：
    * 判断：
        * 什么时候对这一增长划界
        * 什么时候将对这一增长通知客户

* 观察（Observation)
    * 通过观察用户执行其现行的任务和过程，或通过观察他们如何操作与所期望的新系统有关的现有系统，了解系统运行的环境，特别是了解要建的新系统与现存系统、过程以及工程方法之间必须进行的交互。尽管了解这些信息可以通过交谈获取，但“第一手资料”一般总是能够比较好的“符合现实”的
    * 存在的风险：
        * 客户可能抵触这一观察。其原因是他们认为开发者打扰了他们的正常业务
        * 客户还可能认为开发者在签约之前，就已经熟悉了他们的业务

* 小组会（Group session)
    * 举行客户和开发人员的联席会议，与客户组织的一些代表共同开发需求。其中：
        * 通常是由开发组织的一个代表作为首席需求工程师或软件项目经理，主持这一次会议。但还可以采用其它形式，这依赖于其应用领域和主持人的能力。主持人的作用主要是掌握会议的进程
        * 必须仔细地选择该小组的成员，不仅要考虑他们对现存的和运行环境的理解程度，还要考虑他们的人格

* 提炼 （Extraction)
    * 复审技术文档（例如，有关需要的陈述，功能和性能目标的陈述，系统规约接口标准，硬件设计文档以及 ConOps 文档），并提出相关的信息
        * 适用条件：提炼方法是针对已经有了部分需求文档的情况。依据产品的本来情况，可能有很多文档需要复审，以确定其中是否包含相关联的信息。在有的情况，也可能只有少数文档需要复审
        * 在许多项目中，在任何交谈、观察、小组会或自悟之前，应该对该项目的背景文档进行复审，还应对系统规约进行复审，同时了解相关的标准和政策


### 需求规约的概念和格式
* 概念
> 一个需求规约是一个软件项目/产品/系统所有需求陈述的正式文档，是一个软件产品/系统的概念模型

* 基本性质
    * 重要性和稳定性程度，例如：可选的需求和期望的需求
    * 可修改的：在不过多地影响其它需求的前提下，可以容易地修改一个单一需求
    * 完整的：没有被遗漏的需求
    * 一致的：不存在互斥的需求
* 其中就功能的需求规约来说，还应考虑以下问题：
    * （1）功能源 （2）功能共享的数据 （3）功能与外部界面的交互 （4）功能所使用的计算资源

* 格式
    * 在获取以上初始需求的基础上，可采用IEEE标准的样式，完成一个完整的需求文档草案的编制工作


### 需求规约的作用
* 概述
    * 第一，是最重要的，作为软件开发组织和用户之间一份事实上的技术合同书；是产品功能及其环境的提现
    * 第二，对于项目的其余大多数工作，它是一个管理控制点
    * 第三，对于产品的设计，它是一个正式的、受控的起始点
    * 第四，是创建产品验收计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档——初始测试计划和用户系统操作描述

* 软件测试计划
    * 主要内容：对未来系统中的哪些功能和性能指标进行测试，以及达到何种要求
    * 作用：指导系统开发早期发现并修改一个错误，减少测试代价
    * 用户系统操作描述
        * 主要内容：从用户使用系统的角度，简要描述系统功能和性能，使用系统的主要步骤和方法，以及系统用户的责任等
*注，相当于一份初步的用户手册*
> 作用：在软件开发的早期，准备一份初步的用户手册可以使未来的系统能够从使用的角度检查、审视目标系统，从而比较容易判断这个系统是否符合他们的需要。为了书写这样的文档，也会迫使系统分析员从用户的角度来考虑软件系统。这样不论是否审查还是复审时，就更容易发现不一致和误解的地方，这对保证软件质量和项目成功是很重要的

* 需求规约不能实现的作用
    * 第一，它不是一个设计文档。它是一个“为了”设计的文档
    * 第二，它不是进度或规划文档，不应该包含更适宜包含在工作陈述、软件项目管理计划、软件生存周期管理计划软件配置管理计划或软件质量保证计划等文档中的信息。
        * 因此，在 SRS 中不应该给出：
            * 项目成本：交付进度；报告流程；
            * 软件开发方法；质量保证规划；配置管理规程
            * 验证和确认规程：验收规程；安装规程

### 需求验证
* 有关 SRS 内容方面
    * 正确性
    > 指的是 SRS 中陈述的每个需求都表达了将要构造的系统的某个要求
    
	* 无二义性
    > 指的是 SRS 中陈述的每个需求都只有一种解释
    
	* 完整性
    *若一个 SRS 具有以下三个特性，则它是完整的：*

    > 未来系统所做的任何事情都包含在 SAS 的陈述中

    > 未来系统响应所有可能的输入（包括有效和无效）

    > SRS 中没有被标识为“待定”的内容

    * 可验证性
        * SRS 中陈述的每个需求都是可验证的，即当且仅当存在一个有限代价的过程（人工或机器）可以检查构造的软件产品是否符合用户的需求
            * 任何二义性必然导致不可验证性
            * 任何不可度量的量，如“通常”或“时常”等
	    * 任何等同于停机问题的需求是不能验证的，如“程序将不会进入一个无限循环“等同于停机问题，因而是不可验证的

    * 一致性
        * SRS 中陈述的需求没有与以前的文档发生冲突
        >* SRS 中陈述的各个需求之间没有发生冲突
    * 可理解性

* 有关 SRS 格式与风格方面
    * 可修改性
    > 指的是 SRS 的结构和风格使任何对需求法必要修改都易于完整、一致的进行
    
	* 可被跟踪性
    > 指的是 SRS 中的每个需求的出处都是清除的，这意味着 SRS 中包含对前期支持文档的引用表
    
	* 可跟踪性
    > 指的是 SRS 的书写方式有助于对其中的陈述的每个需求进行引用
    
	* 设计无关性
    > 指的是 SRS 不暗示特定的软件结构和算法
    
	* 注释
    > 向开发机构提供了每个需求是否重要的指导意见。如：E（Essential)、D(Desirable) 或 O(Optional)


### 项目需求及需求规约
* 项目需求的概念
    * 项目需求是客户和开发者之间有关技术合同—产品/系统的需求的理解，应记录在工作陈述 SOW 或其他某一项文档（例如，项目管理计划）中
        * 即 SRS 应只关注产品需求，即：
            * 产品/系统需求—“交付给客户的产品是什么”
        * SOW应关注项目工作与管理，即：
            * 项目需求—“开发组要做什么”

* 项目需求与软件需求的区别

### 结构化设计的概念
* 设计的定义
	* 一种软件开发活动，定义实现需求规约所需的软件结构
	> 设计目标：依据需求规约，在一个抽象层上建立系统软件模型，包括软件体系结构（数据和程序结构），以及详细的处理算法，产生设计规格书
	
	> 即：**要回答如何解决问题—给出软件解决方案**

	* 结构设计分为： 
   		* 总体设计：确定系统的整体模块结构，即系统实现所需要的软件模块以及这些模块之间的调用关系
    	* 详细设计：详细描述模块
* 整体框架
	* 对设计方法的需求
    	* **提供可提现“原理/原则”的一组术语**（符号），形成一个特定的抽象层，用于表达设计中所使用的部件
    	* 依据术语形成的“空间”，**给出表达软件模型工具**
    	* **给出设计的过程指导**

* 总体设计层概述
    * 第一阶段，初步设计。在对给定的数据流图进行复审和精化的基础上，将其转化为初始的结构模块图。**根据穿越系统边界的数据流初步确定系统与外部的接口**
    * 第二阶段，精化设计。依据模块“高内聚低耦合”的原则，精化初始的模块结构图，**并设计其中的全局数据结构和每一模块的接口**
    * 第三阶段，设计复审阶段，对前两个阶段得到的高层软件结构进行复审，必要时还可能需要对软件结构做一些精化工作
 
### 结构化分析模型
* 基本术语
    * 一个抽象层是由一组确定的术语定义的，为支持需求分析中有关要使用的那些信息的表达，结构化分析方法给出了以下五个术语/符号：

* 模型表达工具
    * DFD图
    	* **表达系统功能模型的工具**，是一种描述数据变换的图形工具，它包含的元素可以是数据流、数据存储、加工、数据源和数据谭等

    * 数据字典
    	* **定义数据流和数据存储**，用于定义数据流和数据存储的结构，并给出构成所给出的数据流和数据存储的各数据项的基本数据类型

    * 加工小说明
    	* 判定表或判定树等，描述加工“做什么”，即加工逻辑，也包括其它一些与加工有关的信息，如执行条件、优先级、执行频率、出错处理等
    	* 判断表：适应于加工的输入数据和输出数据之间的逻辑关系比较复杂的加工描述
    	* 判定树：适用于加工的输入数据和输出数据之间的逻辑关系比较复杂的加工描述
		* 结构化自然语言
    		* 适用于加工的输入数据和输出数据之间的逻辑关系比较简单的加工描述
```   
 例如：if 20<订阅量
     then 订票折扣为10%
     else 订票折扣为5%
```
    
### 结构化分析过程
* 过程指导
    * 建立系统的功能模型
    * 建立数据字典
    * 给出加工小说明

* 顶层数据流图

* 自顶向下，逐步分解

* 建立数据字典

* 给出加工小说明
	* 描述一个加工，一般遵循如下模板
		* 加工编号：给出加工编号
		* 加工名：给出加工的标识
		* 输入流：给出该加工的所有输入数据流
		* 输出流：给出该加工的所有输出数据流
		* 加工逻辑：采用结构化自然语言或判定表、判定树等工具，给出该加工输入数据和输出数据之间的关系

* 建模应注意点问题
    * 结构化分析方法是一种半形式化的规约方法，给出了一组特定的术语表和标准化的表达格式—数据流图，在表达上均必须遵循一些约定，即应以一种准确和一致方式使用
    * 例如：
        * 加工：其标识应使用领域术语，采用动宾结构；必须有输入和输出
        * 数据流：其标识应使用领域术语，采用名词或名词短语；特别，应注意模型平衡问题和信息组织的复杂性控制问题

* 补充案例
    * 问题陈述
    * 建立顶层数据流图
    * 自顶向下，逐步求精
    * 建立系统的数据字典
    * 建立加工小说明
### 需求规格说明书
* 引言

* 概述

* 接口
    * 用户接口
    * 硬件接口
    * 软件接口

* 性能需求
    * 精度
    * 时间特征
    * 灵活性

* 属性
    * 可使用性
    > 规定某些需求，如检验点、恢复方式和重启动性，以确保软件可使用
    
	* 保密性
    > 规定保护软件的要素
    
	* 可维护性
    * 可移植性

* 其他需求
    * 数据库
    * 操作
    * 故障及处理
   
### 初始模块结构图的设计
* 数据流图的分类
    * 变换型 DFD
    * 事务型 DFD
* 变化设计的基本步骤
    * 第一步：设计准备，复审并精化系统模型

    * 第二步：确定输入、变换、输出这三部分之间的边界

    * 第三步：第一级分解，系统模块结构图顶层和第一层设计

    * 第四步：第二级分解，自顶向下、逐步求精

* 事务设计的基本步骤
    * 第一步：设计准备，复审并精化系统模型

    * 第二步：确定事务处理中心

    * 第三步：第一级分解，系统模块结构图顶层和第一层设计

    * 第四步：第二级分解，自顶向下、逐步求精


### 初始模块结构图精化的原则
* 精化的概念
    * 模块、模块化
        * 基于模块化原理-高内聚、低耦合，
        * 给出设计规划-经验规则-启发式规则
        * 用于精化初始的 MSD
        * 体现设计人员的创造


* 模块和模块化
	* 模块：执行一个特殊任务的一组例程和数据结构
	* 接口：给出可由其他模块和例程访问的对象
		* 常量，变量，数据类型，函数
	
	* 实现：接口的实现（模块功能的执行机制）
		* 私有量，过程描述，源程序代码

	* 模块化：把系统分解成若干模块的过程
		* 50对年的历史
		* 软件的单个属性，使得程序能够被理性的管理

* 为什么要模块化
	* 一个理想的情况
		* 如果我们能够无限制地划分软件，那么开发它所需的工作量可以变得非常小，乃至可以忽略！

		* 但是，这个结论是错误的

		* 随着模块数量的增长，集成模块所需的工作量（成本）也在增长

* 基本原则：**高内聚、低耦合**

* 耦合
	* 定义：不同模块之间相互依赖程度的度量
	* 原则：**如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，坚决避免使用内容耦合**


* 内聚
	* 定义：一个模块之内各成分之间相互依赖程度的度量

	* 好的设计满足：

	> 模块的功能单一

	> 模块的各部分都和模块的功能直接相关

	> 高内聚


### 总体设计案例
* 确定逻辑输入和逻辑输出
* 输入部分的进一步精化
* 输出部分的进一步精化


### 初始化模块结构精化的启发式规则
* 常见的启发式规则
	* 什么叫做“启发式”？
	> 根据设计标准，从长期的软件开发实践中，总结出来的规则

	> 既不是设计目标，也不是设计时应该普遍遵循的原理

	* 常见的六种启发式规则
		* 改进软件结构，提高模块独立性
		* 模块规模适中，每页60行语句
		* 深度、宽度、扇入和扇出适中
		* 模块的作用域力争在控制域之内
		* 降低模块接口的复杂性
		* 模块功能应该可以预测

* 输入部分的精化

* 输出部分的精化

* 变换部分的精化
> 对于变换部分的精化，是一项具有挑战性的工作。其中主要是根据设计准则，并要通过实践，不断地总结经验，才能设计出合理的模块结构


### 接口设计
> 系统的接口设计是由穿过系统边界的数据流定义的

> 在最终的系统中，数据流将成为用户界面中的表单、报表或与其他系统进行交互的文件或通信

* 接口设计的分类
	* 模块或软件构件间的接口设计
	* 软件与其他软硬件系统之间的接口设计
	* 软件与人（用户）之间的交互设计

**系统的接口设计（包括用户界面设计及与其他系统的接口设计）是由穿过系统边界的数据流定义的**

* 人机交互界面
    * 用户界面应具备的特性
    	* 可使用性
    	* 灵活性
    	* 可靠性
    * 用户类型
    	* 外行型：对计算机系统认知很少或毫无了解
    	* 初学型：对计算机有一定经验，对系统的认识不足或经验不足，需要很多界面支持
    	* 熟练型：对一个系统有很多经验，需要较少的界面支持，但不能处理意外错误
    	* 专家型：了解系统的内部构造，需要为他们提供能够修改和扩充系统能力的复杂界面
    * 界面设计类型
    	* 问题描述语言
    	* 数据表格
    	* 图形
    	* 菜单
    	* 对话
    	* 窗口
    	* ...

    **一个界面的设计通常使用一种以上的设计类型，每种类型与一个或一组任务相匹配**
    
	* 设计原则 
    	* 遵循的原则：
   			* 一致性
    		* 操作步骤少
    		* 不要“哑巴放”
    		* 提供Undo功能
    		* 减少人脑的记忆负担
    		* 提高学习效率
	
	**在设计阶段，必须根据需求把交互细节加入到用户界面设计中，包括人机交互所必须的实际显示和输入**


### 数据设计
*在设计阶段必须对要存储的数据及其格式进行设计*

* 文件设计
> 文件设计的主要工作就是根据使用要求、处理方式、存储的信息量、数据的活动性以及所提供的设备条件等确定文档类型，选择文件媒体，决定文件组织方法，设计文件记录格式，并估算文件的容量

* 数据库设计
> 在结构化设计中，很容易将结构化分析阶段建立的数据字典和实体-关系模型映射到关系数据库中

> 数据对象的映射

> 关系的映射


### 详细设计工具
* 详细设计概览
* 伪码
	* 优点：PDL 不仅可以作为设计工具，而且可作为注释工具，直接插在源程序中间，以保持文档和程序的一致性，提高了文档的质量
	* 缺点：不如图形工具那样形象直观；当描述复杂的条件组合与动作间的对应关系时，不如判定表和判定树那样简单清晰
* 程序流程图
	* 优点：对控制流程的描绘很直观，便于初学者掌握
	* 缺点：不是一种逐步求精的工具，程序员过早地考虑程序的控制流程，而不是全局结构；所表达的控制流，可以不受约束随意转移；不易表示数据结构
* PAD 图
	* 优点：支持自顶向下、逐步求精的结构化详细设计，可使用“def”符号逐步增加细节
	* 优点：PAD 图最左边的竖线是程序的主线，随着程序层次的增加，逐步向右延伸，每增加一个层次，图形向右扩展一条竖线，从而使 PAD 图所表现的处理逻辑易读、易懂和易记
* N-S 图
	* 支持自顶向下、逐步求精的结构化详细设计，并且严格限制了控制从一个处理到另一个处理的转移
* 判定表和判定树
	* 清晰地表达复杂的条件组合与应做的动作之间的对应关系，形势简单，简洁
	> 当算法中包含多重嵌套的条件选择时，用程序流程图、盒图、PAD 图、PDL 图都不易清除地描述，这时可以选择判断表来表达复杂的条件组合与应做的动作之间的对应关系


### 软件设计规约
* 概念和组成
	* 概念：软件设计规约对软件的组织或其组成部分的内部结构的描述，满足系统需求规约所指定的全部功能及性能要求
	* 组成：软件设计规约通常有**概要设计规约**和**详细设计规约**，分别为相应设计过程的输出文档
* 概要设计规约
	* 指明软件的组织结构，其主要内容包括：
	* 系统环境
	* 设计描述
	* 对每个模块的描述
	* 文件结构和全局数据
	* 软件测试方面的要求和说明

	> 软件概要设计是面向软件开发者的文档，主要作为**软件项目管理人员、系统分析人员与设计人员之间**交流的媒体

* 详细设计规约
	* 对软件各组成部分内部属性的描述，它是概要设计的细化。即在概要设计规约的基础上，增加以下内容：
		* 1、各处理过程的算法
		* 2、算法所涉及的全部数据结构的描述，特别地，对主要数据结构往往包括与算法实现有关的描述
		> 软件设计规约主要作为**软件设计人员与程序员之间**交流的媒体

* 设计规约格式


### 结构化方法总结
* 结构化方法的世界观
* 基本原理和原则
* 抽象层
* 组成
* 问题



### 软件设计评审
* 概念
* 方法
* 指南
* 评审检查表


### 面向对象方法的概念
* 什么是面向对象
	* 面向对象方法是一种以对象、对象关系等来构造系统模型的系统化方法
	* 面向对象方法的世界观：一切系统都是由对象构成的，它们的相互作用、相互影响，构成了大千世界的各式各样系统
	* 面向对象不仅仅是一种程序开发方法
	* 面向对象是一种软件方法学
* 面向对象方法的主要特点
	* 1、问题域中客观存在的事物出发来构造软件系统，用对象作为对这些事物的、抽象表示，并以此作为系统的基本构成单位
	* 2、对象的属性和操作结合为一体，构成一个独立的实体，对外屏蔽其内部细节（封装）
	* 3、对事物进行分类，把具有相同属性和相同操作的对象归为一类，类是这些对象的抽象描述，每个对象是它的类的一个实例
	* 4、通过在不同程度上运用抽象的原则，可以得到较一般的类和较特殊的类。特殊类继承一般类的属性与服务，面向对象方法支持对这种继承关系的描述与实现，从而简化系统的构造过程及其文档。
	* 5、复杂的对象可以用简单的对象作为其构成部分，称作聚合
	* 6、对象之间通过消息进行通信，以实现对象之间的动态联系
	* 7、通过关联表达对象之间的静态关系
* 面向对象方法的基本思想
> 从现实世界中客观存在的事物出发建立软件系统

> 充分运用人类日常的思维方法

> 面向对象方法真正意义深远的目标是它适合于解决分析与设计期间的复杂性并实现分析与设计的复用

* 面向对象方法学习什么
	* 基本概念、主要思想
	* 面向对象的分析（OOA）
	* 面向对象的设计（OOD）
	* 面向对象的程序设计（OOP)

### UML 的概念
* 概述
* 面向对象方法术语/符号

### 类与对象
* 定义与表示
	* 类（class）：是一组具有相同属性、操作、关系和语义的对象的描述
	* 对象（object）：对象是类的一个实例

* 类名
	* 类名使用黑体字，第一个字母通常要大写，并位于第一栏的中央
	* 类名往往是从正被建模的词汇表中提取的简单名词或名词短语

* 属性
	* 属性是类的一个命名特性，由该类的所有对象所共享，用于表达对象状态的数据
	* 一个属性往往具有所属的类型，用于描述特性的实例可以取值的范围
	* 类的一个对象对每一个属性应有特定的值
	* 一个类可以有多个属性，也可以没有属性

* 操作
	* 操作是对一个类中所有对象要做的事情的抽象
	* 一个类可以有多个操作，也可以没有操作
	* 操作名除第一个词之外，其他每个词的第一个字母要大写
	* 操作名往往是描述其所在类的行为的动词或动词短语
	* 可以通过给出操作的特征标记进一步描述之，特征标记通常包括参数名、类型和默认值；如果该操作是一个函数，那么其特征标记还包括返回类型
	* 操作可以使抽象操作，即没有给出实现的操作。此时的操作名采用斜体。注：抽象操作映射到C++称为纯虚操作
	* 调用一个对象上的操作可能会改变该对象的数据或状态

* 操作的多态性

### 表达结构化事物的术语/符号
* 类和对象
* 接口（interface)
	* 概念：接口是一组操作的集合，其中每个操作描述类或构件的一个服务
	* 接口的基本作用：模型化系统中的“接缝”

* 协作（collaboration)
	* 协作是一组类、接口和其他元素的群体，它们共同工作以提供比各组成部分的总和更强的合作行为

	* 协作是一个交互、涉及交互三要素：交互各方、交互方式以及交互内容。交互各方的共同工作提供了某种协作行为

* 用况（use case)
	* 体现功能的抽象，是对一组动作序列的描述，系统执行这些动作产生对特定的参与者一个有值的、可观察的结果

* 主动类（active class)
	* 体现并发行为抽象，是一种至少具有一个进程或线程的类，因此它能够启动控制活动

* 构件（component)
	* 构件是系统中逻辑的并且可替换的成分，它遵循并提供了一组接口的实现

* 制品（artifact)
	* 制品是系统中物理的、可替代的部件，其中包含物理信息（比特）

* 节点（node)
	* 是在运行时存在的物理元素，通常它表示一种具有记忆能力和处理能力的计算机资源


### 包的概念
* 语义
> 包是模型元素的一个分组。一个包本身可以被嵌套在其它包中，并且可以含有子包和其它种类的模型元素

* 表示
* 包之间的关系
* 对成组的元素建模策略
	* 浏览特定体系结构，视图里面的建模元素，找出概念和语义上相近的元素所定义的组块。
	* 把这样的一些块放到一个包里。
	* 对每个包判别哪些元素要在包外访问， 把这些元素标记为公共的，把其他元素标记为受保护的或者私有的。
	* 用引入依赖关系显式地连接建立在其他包之上的包。
	* 在包的家族里面，用泛化关系把特殊包连接到一般包里面。


### 表达关系的术语
* 关联（association)
	* 关联是类目之间的结构关系，描述了一组具有相同结构、相同语义的链（links)
	* **链是对象之间的连接（connection）**

* 泛化（generalization)
	* 泛化是一般性事物（称为超类或父类）和它的较为特殊种类（称为子类）之间的一种关系，有时称为“is-a-kind-of"关系

* 细化，也称实现（realization)
	* 细化是类目之间的一种语义关系，其中一个类目规约了保证另一个类目执行的契约

* 依赖（dependency)
	* 依赖是一种使用关系，用于描述一个事物（如类 Window）使用另一事物（如类 Event )的信息和服务


### UML 基本关系的一般用法
* 模型化简单依赖
* 模型化单继承
* 模型化结构关系
